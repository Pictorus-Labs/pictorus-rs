There are 2 crates in this workspace:

## px4-msgs-sys
Contains generated rust code for the uOrb message structs. This was generated with Bindgen originally, but I ended up using the output to create a static set of .rs files since I was modifying them a decent bit. The files they were generated off of are in a `c_api` folder, but there is no bindgen that happens at build time the way it is done in the new-eagle crate.

`orb.rs` contains structs and functions used to talk to the uOrb system. `message_defs.rs` contains the actual message structs that were made with bindgen. It exports extern declarations for each message "topic" in uOrb. Most messages map 1:1 with a topic, but some message definitions are used for multiple topics (i.e. the `wind_s` message is published as `__orb_wind` and `__orb_estimator_wind`). And finally, ENUM declarations bindgen grabbed from the message defs that are currently going unused, but we will need to integrate with at some point.

## pictorus-px4
The actual API for Pictorus <-> PX4 communication:
 - `lib.rs` mostly brings in the other modules but also has an impl of critical_section that does nothing right now. This might be ok, but we'll need to really convince ourselves of that or make a real impl.
 - `message_impls.rs` defines a struct for each Message Topic that is used by the rust API to refer to Message topics we can subscribe to or advertise to. Each struct implements the Topic trait explained below. A macro defines one of these for every topic in the system. It also defines 4 traits:
    - `UorbMessage`: offers a way to turn message structs into bytes and create a view of them from bytes. This is generated by macro for all the message defs from the px4-msgs-sys crate.
    - `Topic`: An advertised topic in the uOrb system.
    - `ToPassType` and `FromPassType`: Implemented for message structs, offers a way to turn a message struct to and from a pass type (e.g. `(f64, Matrix<f64, 3,4>, ...)`). These must be hand written for now.
 - `ffi_protocol.rs` serves as the bridge between Pictorus and the C++ shim module. It defines an FFI_Protocol singleton that the model must configure at initialization by calling `subscribe_to_message` and `advertise_message` for each topic it must be able to work with respectively. This is done using the topic structs in the module above. There are then two structs `FfiInputBlock` and `FfiOutputBlock` which are generic over a specific Topic struct type. They don't require any runtime parameters. The model is free to call input and output on them as needed during execution.
 
 ### Interface from the Shim/C++ side
 
 The shim gets access to the following from the Rust side:
 ```c++
/// C-compatible error codes for FFI boundary (matches Rust FfiReturnCode)
typedef enum {
    /// Success - no error
    FFI_SUCCESS = 0,
    /// Message length mismatch
    FFI_MESSAGE_LENGTH_MISMATCH = 1,
    /// Attempt to get message type that has not been advertised
    FFI_UNADVERTISED_MESSAGE = 2,
    /// Attempt to get message type that has not been subscribed
    FFI_UNSUBSCRIBED_MESSAGE = 3,
    /// Invalid message index
    FFI_INVALID_MESSAGE_INDEX = 4,
    /// Null argument(s) passed to function
    FFI_NULL_ARGUMENT = 5,
} FfiError;

extern "C" {
// Message Input (i.e. C++ inputting to Rust)
FfiError rust_get_input_message_count(size_t* count);
FfiError rust_get_input_message_id(size_t index, orb_id_t* message_id);
FfiError rust_write_input_message(orb_id_t message_id, const uint8_t* data, size_t len);
// Message Output (i.e. C++ taking output from Rust)
FfiError rust_get_output_message_count(size_t* count);  
FfiError rust_get_output_message_id(size_t index, orb_id_t* message_id);
FfiError rust_output_message_has_update(orb_id_t message_id, bool* has_update);
FfiError rust_read_output_message(orb_id_t message_id, uint8_t* buffer, size_t buffer_size, size_t* bytes_written);
}
```

This is in addition to the usual exports we offer with a static library for instantiating and running a model. Generally on each timestep the C++ will start by using `rust_get_input_message_count` to create a for-loop. Then for each message it will retrieve the message's `orb_id_t` with `rust_get_input_message_id`. It can then use this to check if the message has any updates since the last run (if this is the first time it has seen this particular message, it will also have to subscribe to the message before it can check for it). Finally, if there was an update, it will use `rust_write_input_message` to copy that message into the Rust app.

Then the app can be run for one timestep as usual. One modification I made was to have the `app_interface_update` take a `u64` timestamp in microseconds instead of our usual seconds in `f64`/`double`. Internally we were already converting that float into a `u64` microsecond value, and that is what PX4 supplies in their API and what is used in all their messages. The `hrt_absolute_time()` will get you that value.

Finally, after the model has run, a similar process to what we did with input messages takes place. Get the count, iterate over 0..Count, get each message id. Then you can check if the message has an update to be published with `rust_output_message_has_update`. If it does, you can read the message out with `rust_read_output_message` and publish it (remembering to "advertise" the message if you have never published it before). 

#### API Complexity vs. Safety
The first version of this API for the shim to use only had two functions. It was in many ways much simpler and much more efficient, however it was also much less safe. The old scheme involved passing raw pointers to memory that Rust had allocated to the C++ API and relying on the C++ API to not misuse them. The new API incurs a redundant copy of each message that goes in or out but does not ever expose raw pointers that the C++ code is expected to write into.

#### API Safety in General
This API makes the assumption that the C++ and Rust will all run in one task/thread. It will fall down miserably if it is run concurrently.

## Module Shim
Finally there is a folder `module_shim`. This is not a crate and not in the workspace's Cargo file. It is the C++ shim along with all the required CMake files to be built as an "external" px4 module. Right now `module_shim/src/modules/pictorus_module/CMakeLists.txt` must be updated with the path to the static lib generated by cargo build. With that updated, you can run cargo build and then switch to your PX4 repo and run a command like this: `make px4_sitl_default none EXTERNAL_MODULES_LOCATION=../pictorus-px4-workspace/module-shim` and the firmware will be built with the rust library and shim in place as a module called `pictorus_module`.

# Notes On Designing an App and Running it


## Using a module for attitude control

In order to use a custom module (any custom module, pictorus, simulink or otherwise) as an attitude controller, we need to disable a few built-in modules that would interfere, and we need to publish the right messages to make the system actually do something.

Modules to Disable:
 - navigator
 - commander
 - mc_att_control
 - mc_rate_control
 - mc_pos_control

They can be disabled on the px4 shell (e.g. `navigator stop`), or you could potentially remove them from the system startup script (how simulink does it), or you could potentially even not build them into the firmware at all (Not 100% sure the implications here: would some messages be left out for example?). Another interesting area to look into would be to potentially only disable some of these modules and only try to take on some of the responsibilities in your model. For instance, you could try replacing just the rate controller maybe.

All modules are tied together with uOrb messages. If you disable a module or many, you can still get the rest of the system to do things if you know what messages to send them. In the case of the Quad Controller example I had to publish to the `actuator_motors` and `actuator_armed` messages. Just those two together is enough to get the motors spinning under the model's command. Obviously, to do anything useful you need data input as well. For this I tapped into the `vehicle_odometry` and `manual_control_input` messages. These give the vehicle's estimated attitude, position and velocities, and the RC transmitter/Joystick inputs respectively.


## PX4 Parameter <-> Pictorus FFI Variable Interop

It looks like it shouldn't be too difficult to expose Pictorus FFI Input Variables as parameters in PX4/QGroundControl. To make this work we would have to:
   1. gather all the FFI input variables similar to how it is currently done in `c_binidngs_module.py`.
   1.  add them as entries in the `module.yaml` file in the shim module folder. By PX4 convention they should be all caps with underscores and all have a unique prefix (e.g. `PICT_FOO_BAR`, and `PICT_ROLL_P_GAIN`). PX4 paramters can be either a `float` or an `int` while pictorus FFI variables can be a string or a float - so for now all variable that want to jump the gap will have to be floats. In the yaml entries the `description: short:` is mandatory and will have to be filled with something.
   1. Add corresponding entries for each parameter in the call to the `DEFINE_PARAMETERS()` macro in `pictorus_module.h`. This combined with the class's inheritance from `ModuleParams` and the `update_parameters()` function which gets called at the top of each loop will ensure that the named variables (e.g. `_pict_foo_bar`) will always have the most up to date value for their corresponding parameter.
   1. In the `pictorus_module.cpp` file use these member variables that are being kept in sync with their parameter backing to update the `AppDataInput` struct that was put in place by our existing codegen.

As an improvement it could be worth avoiding updating the values in `AppDataInput` unless there are actually changes. This could be done by modifying `parameters_update()` to take a reference to the `AppDataInput`. That function already does a similar thing: using a cheap function call to see if there are updates which calls the expensive function that does the actual data updating if necessary. Generally param updates are probably relatively rare in the lifecycle of a model running.

### Making sure the Params show up

PX4 has a notion of a param being "used". By default the tooling will only show used parameters (e.g. with `param show`, to see all parameters use `param show -a`). In fact in QGroundControl I couldn't find anyway to show unused parameters. To make a parameter "used" something has to interact with it at least once since the device has booted. If our model is in the start up script then this is a non-issue and our params will always be used. If not, and we want the parameters to be visible even before a model has been started we need to kick it somehow. One easy way to do this is with `param touch PICT_FOO_BAR`, this could be run as a command on the shell or in the start-up script for the board. Either way once it has been run once for a given boot that variable will now be visible in QGroundControl and with `param show`. Down the line it probably also wouldn't be too hard to make an `init` or `param_init` sub-command for the pictorus module we are defining in the C++ code that doesn't start the model but does kick the params to get them marked `used`. This could be added unconditionally to the start-up script



### A Note on Arming

Without sending the `actuator_armed` message the motors won't move. This model very crudely just arms itself the second it starts up. This is not very bright and it should really be handled with some sort of state machine or similar.

## Notes on SITL

Getting Gazebo working was a huge pain. It is really only made to run on the most recent Ubuntu LTS version. Since my laptop has a one version newer Ubuntu installed, getting Gazebo going was a nightmare. For future work it'd probably be best to use a dedicated machine or VM that is just running Ubuntu LTS. This would make the PX4 dev environment easier to get going as well as make getting Gazebo a matter of a few commands.

Broadly to get it working I had to install a bunch of dependencies (including pointing my newer ubuntu to an OpenSourceRoboticsFoundation repo for the last version that thankfully just worked), setup a venv for python 3.11, use that venv to download and build Gazebo with the website's instructions. With that built you will have an `install` directory with a `setup.bash` (and `setup.zsh`) script that you need to run to put Gazebo on your path. I was still having issues with Gazebo not finding the python 3.11 dynamic libraries. The fix there is to add `/home/jason/.pyenv/versions/3.11.13/lib` to my LD_LIBRARY environmental variable anytime I want to run Gazebo (you'll see this in action further down). 

## Building PX4 and Running SITL

To run the SITL simulation you can use the simulation make targets that PX4 provides. The command will be `make px4_sitl gz_x500 EXTERNAL_MODULES_LOCATION=../pictorus-px4-workspace/module-shim`. This will only work if all the dependencies and Gazebo are all installed, activated, and otherwise happy when you first run `make`. If you get back an error saying something along the lines of `target does not exist` when you try to run the SITL make command, but can otherwise build the firmware with the command `make px4_sitl EXTERNAL_MODULES_LOCATION=../pictorus-px4-workspace/module-shim`, that means that Gazebo isn't happy or some dependency is missing, or similar. Look through the `make` output to try and find the issue, fix it, and then run `make distclean` and try again. The `distclean` is very important!

## QGroundControl Setup
When the PX4 firmware starts up it should automatically connect to QGroundControl. QGroundControl can use a normal Xbox Joystick as a stand-in for an RC Transmitter. With a controller plugged in and the SITL started, you should see a "Joystick" pane in the vehicle configuration page. Setup is pretty trivial. I ended up toying with a few other parameters but I'm not sure if any of them ended up mattering. But for posterity, the ones I was playing with include: `COM_RC_IN_MODE`, `COM__MODE_ARM_CHK`, and `COM_ARM_SWISBTN`. I think some of those may only matter if you have the `commander` module running (which we don't), but they did play a part in letting me fly the quad before I stopped all those modules to validate that everything else was working.

## Putting it all together

### Build the Pictorus App
`cargo build --example=quad_controller --package=pictorus-px4`

### Start QGroundControl
Self explanatory, make sure your joystick is connected.

### Build and start the PX4 Firmware
In the PX4 repo, setup your terminal environment (this only needs to be done once per terminal, or could be added to `.bashrc` or similar):
```bash
$ . ~/vcs_colcon_installation/bin/activate
$ . ~/Workspace/Pictorus/Gazebo/install/setup.zsh
$ export LD_LIBRARY_PATH=/home/jason/.pyenv/versions/3.11.13/lib:$LD_LIBRARY_PATH
```
Now you can build the firmware and start the sim in one shot with:
`make px4_sitl gz_x500 EXTERNAL_MODULES_LOCATION=../pictorus-px4-workspace/module-shim`

### Run your app

If all went well, the terminal you ran the make command will build the firmware (if needed), then start Gazebo, then start the firmware and drop you in a PX4 shell. The PX4 shell can be super useful for general debugging. Some highlights:
   - `uorb top`: shows all active uorb topics and their update rate and number of subscribers
   - `listener [some topic name]`: Pretty prints a topic for you, useful to see if your sensors/joystick are feeding good data, and if your app is outputting what you expect

The shell will be where we stop the modules we need to stop and start our module (and also see print statements from our module/the shim). A typical workflow for that would look like:
```bash
______  __   __    ___ 
| ___ \ \ \ / /   /   |
| |_/ /  \ V /   / /| |
|  __/   /   \  / /_| |
| |     / /^\ \ \___  |
\_|     \/   \/     |_/

px4 starting.

INFO  [px4] startup script: /bin/sh etc/init.d-posix/rcS 0
INFO  [init] found model autostart file as SYS_AUTOSTART=4001
INFO  [param] selected parameter default file parameters.bson
INFO  [param] importing from 'parameters.bson'
INFO  [parameters] BSON document size 375 bytes, decoded 375 bytes (INT32:16, FLOAT:3)
INFO  [param] selected parameter backup file parameters_backup.bson
INFO  [dataman] data manager file './dataman' size is 1208528 bytes
INFO  [init] Gazebo simulator
INFO  [init] Starting gazebo with world: /home/jason/Workspace/Pictorus/PX4-Autopilot/Tools/simulation/gz/worlds/default.sdf
INFO  [init] Starting gz gui
INFO  [init] Waiting for Gazebo world...
INFO  [init] Gazebo world is ready
INFO  [init] Spawning model
INFO  [gz_bridge] world: default, model: x500_0
INFO  [lockstep_scheduler] setting initial absolute time to 4136000 us
INFO  [commander] LED: open /dev/led0 failed (22)
WARN  [health_and_arming_checks] Preflight Fail: ekf2 missing data
WARN  [health_and_arming_checks] Preflight Fail: system power unavailable
WARN  [health_and_arming_checks] Preflight Fail: No connection to the ground control station
INFO  [tone_alarm] home set
INFO  [uxrce_dds_client] init UDP agent IP:127.0.0.1, port:8888
INFO  [mavlink] mode: Normal, data rate: 4000000 B/s on udp port 18570 remote port 14550
INFO  [mavlink] partner IP: 127.0.0.1
INFO  [mavlink] mode: Onboard, data rate: 4000000 B/s on udp port 14580 remote port 14540
INFO  [mavlink] mode: Onboard, data rate: 4000 B/s on udp port 14280 remote port 14030
INFO  [mavlink] mode: Gimbal, data rate: 400000 B/s on udp port 13030 remote port 13280
INFO  [logger] logger started (mode=all)
INFO  [logger] Start file log (type: full)
INFO  [logger] [logger] ./log/2025-08-28/22_31_35.ulg
INFO  [logger] Opened full log file: ./log/2025-08-28/22_31_35.ulg
INFO  [mavlink] MAVLink only on localhost (set param MAV_{i}_BROADCAST = 1 to enable network)
INFO  [mavlink] MAVLink only on localhost (set param MAV_{i}_BROADCAST = 1 to enable network)
INFO  [px4] Startup script returned successfully
pxh> INFO  [commander] Ready for takeoff!
pxh> commander stop
pxh> navigator stop
pxh> mc_rate_control stop
pxh> mc_att_control stop
pxh> mc_pos_control stop
pxh> pictorus_module start
pxh> INFO  [pictorus_module] PictorusModule started
INFO  [pictorus_module] Subscribing to input message with id 0x6355a9ac7980
INFO  [pictorus_module] Subscribing to input message with id 0x6355a9ac7520
INFO  [pictorus_module] Advertising output message with id 0x6355a9ac73e0
INFO  [pictorus_module] Advertising output message with id 0x6355a9ac55c0
```

## Debugging
If anything is going wrong it isn't too bad to use GDB with all of this (although I could not get it working in VS Code so I had to brush up on my terminal GDB skills). Make sure you have compiled your app in the `dev` profile (i.e. not in `release`), and make sure the shim's `CMakeList.txt` is pointing to your debug firmware. With the SITL running, use `top | grep px4` to get the PID of the firmware process. Then from a terminal in the PX4 repo's root run: `sudo gdb /home/jason/Workspace/Pictorus/PX4-Autopilot/build/px4_sitl_default/bin/px4` (obviously update the path to the location of your firmware executable). In gdb run `directory /path/to/pictorus-px4-workspace` - this will give GDB the ability to add breakpoints in your rust code or step through it. Finally you can run `attach YOUR_PX4_PID` and you are off to the races. After attaching, gdb will pause your firmware. Some quick notes from my debugging:
   - `break quad_controller.rs:137`: sets a breakpoint at line 137 of `quad_controller.rs`
   - `c`: continue the program execution until you hit a break point or pause it again with `Ctrl-C`
   - `s`: step to the next instruction
   - `n`: next, like step but won't go into called functions
   - `fin`: finish the function you are in and pause after return
   - `p [VARIABLE]`: print a variable in memory:
      - `p *this`: from C++ code print the memory of the object you are running in
      - `p this`: print the memory address of the object you are in
      - `p self`: kinda like above but in rust code
      - `p self.my_matrix.data[4]`: You can access members of variables, this is especially helpful to chase references or pointers around
      - `p some_local_var`: also works for local variables and their members
   - `info locals`: print the local variables of the function you are in